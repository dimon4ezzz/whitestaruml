//Generated by the GOLD Parser Builder

using System.IO;

namespace ParserBase
{

// Generated from template grammar specific data    
public class NxGrammarParserBase : GrammarIndependentParserBase
{
    protected delegate void ProductionHandler(GOLD.Reduction reduction);
    
    protected enum SymbolIndex
    {
        @Eof = 0,                                  // (EOF)
        @Error = 1,                                // (Error)
        @Comment = 2,                              // Comment
        @Newline = 3,                              // NewLine
        @Whitespace = 4,                           // Whitespace
        @Timesdiv = 5,                             // '*/'
        @Divtimes = 6,                             // '/*'
        @Divdiv = 7,                               // '//'
        @Lparen = 8,                               // '('
        @Rparen = 9,                               // ')'
        @Bool = 10,                                // bool
        @Flt = 11,                                 // flt
        @Ident = 12,                               // ident
        @Int = 13,                                 // int
        @Math_oper = 14,                           // 'math_oper'
        @Nil = 15,                                 // nil
        @Notation = 16,                            // notation
        @Onarrange = 17,                           // onarrange
        @Ondraw = 18,                              // ondraw
        @Str = 19,                                 // str
        @Expr = 20,                                // <expr>
        @Expr_list = 21,                           // <expr_list>
        @Functional_expr = 22,                     // <functional_expr>
        @Functional_expr_end = 23,                 // <functional_expr_end>
        @Functional_expr_start = 24,               // <functional_expr_start>
        @Notation_expr = 25,                       // <notation_expr>
        @Onarrange_expr = 26,                      // <onarrange_expr>
        @Ondraw_expr = 27,                         // <ondraw_expr>
        @Oper = 28                                 // <oper>
    }

    protected enum ProductionIndex
    {
        @Notation_expr_Notation = 0,               // <notation_expr> ::= <functional_expr_start> notation <onarrange_expr> <ondraw_expr> <functional_expr_end>
        @Onarrange_expr_Onarrange = 1,             // <onarrange_expr> ::= <functional_expr_start> onarrange <expr_list> <functional_expr_end>
        @Ondraw_expr_Ondraw = 2,                   // <ondraw_expr> ::= <functional_expr_start> ondraw <expr_list> <functional_expr_end>
        @Functional_expr = 3,                      // <functional_expr> ::= <oper> <expr_list> <functional_expr_end>
        @Functional_expr_start_Lparen = 4,         // <functional_expr_start> ::= '('
        @Functional_expr_end_Rparen = 5,           // <functional_expr_end> ::= ')'
        @Oper_Ident = 6,                           // <oper> ::= <functional_expr_start> ident
        @Oper_Math_oper = 7,                       // <oper> ::= <functional_expr_start> 'math_oper'
        @Expr_list = 8,                            // <expr_list> ::= <expr_list> <expr>
        @Expr_list2 = 9,                           // <expr_list> ::= 
        @Expr_Flt = 10,                            // <expr> ::= flt
        @Expr_Int = 11,                            // <expr> ::= int
        @Expr_Nil = 12,                            // <expr> ::= nil
        @Expr_Str = 13,                            // <expr> ::= str
        @Expr_Bool = 14,                           // <expr> ::= bool
        @Expr_Ident = 15,                          // <expr> ::= ident
        @Expr = 16                                 // <expr> ::= <functional_expr>
    }

} // End of class NxGrammarParserBase

// Extensions to NxGrammarParserBase to analyze recursively parse tree and call user defined production handlers

public class NxGrammarParserWithTreeProcessing : NxGrammarParserBase

{
    // Internal management of production handlers
    private ProductionHandler[] m_Handlers = new ProductionHandler[System.Enum.GetNames(typeof(ProductionIndex)).Length];

    private void runHandler(ProductionIndex productionIndex, GOLD.Reduction reduction)
    {
        ProductionHandler handler = m_Handlers[(int)productionIndex];
        if (handler != null)
            handler(reduction);
    }

    // Adds a user defined producttion handler
    protected void AddProductionHandler(ProductionIndex productionIndex, ProductionHandler productionHandler)
    {
        m_Handlers[(int)productionIndex] += productionHandler;
    }

    // Traverses recursively the parse tree and looks for grammar productions
    protected void ProcessParseTree(GOLD.Reduction topLevelNode)
    {
        ProductionIndex productionIndex = (ProductionIndex)topLevelNode.Parent.TableIndex();
        runHandler(productionIndex, topLevelNode);

        // Process child nodes recursively 
        for (int i = 0; i < topLevelNode.Count(); i++)
        {
            if (topLevelNode[i].Type() == GOLD.SymbolType.Nonterminal) // Skip terminals at this level
            {
                ProcessParseTree((GOLD.Reduction)topLevelNode[i].Data);
            }
        }
    }
} // End of class NxGrammarParserWithTreeProcessing

} // End of namespace ParserBase
